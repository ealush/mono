<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
		<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; img-src data:image/* https://*; child-src 'none';">
		<title>oh-my-gauge | an npm package by omrilotan</title>
		<meta name="description" content="Gauge and Benchmark - time Javascript operations">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
		<link rel="stylesheet" href="../styles.css">
		<link rel="prerender" href="../">
	</head>
	<body>
		<a href="../">↩︎</a>
		<h1 id="oh-my-gauge">Oh My Gauge! <a href="https://www.npmjs.com/package/oh-my-gauge"><img src="https://img.shields.io/npm/v/oh-my-gauge.svg" alt=""></a> <a href="https://github.com/omrilotan/mono/tree/master/packages/oh-my-gauge"><img src="https://img.shields.io/badge/source--000000.svg?logo=github&style=social" alt=""></a></h1>
<p>time Javascript operations</p>
<pre><code class="language-js">const { Gauge, Benchmark } = require(&#39;oh-my-gauge&#39;);</code></pre>
<h2 id="gauge">Gauge</h2>
<ol>
<li>Create a gauge instance with the results reporting function.</li>
<li>Wrap a function with the gauge. It will return a function that measures the operation, reports it, and returns the given functions&#39; return value.</li>
</ol>
<p>A gauge takes in a function</p>
<pre><code class="language-js">const Gauge = require(&#39;oh-my-gauge&#39;).Gauge;
const gauge = new Gauge((res, name) =&gt; console.log(`${name} took ${res}ms`));
//                        ^     ^        ^
//               Milliseconds String  report-method

const myObj = {
    name: &#39;My Obj&#39;,
    sayName: function() {
        return this.name;
    }
};

myObj.sayName = gauge(myObj.sayName, &#39;sayName method&#39;);</code></pre>
<h2 id="benchmark">Benchmark</h2>
<p>Benchmark compares between multiple operations. It also scrambles the order so running it multiple times can yield more reliable results.</p>
<pre><code class="language-js">const { Benchmark } = require(&#39;oh-my-gauge&#39;);

const benchmark = new Benchmark(); // console.log with default format
-- OR --
const benchmark = new Benchmark(
    sendMetricsToServer, // override the default console.log callback
    (ms, name) =&gt; `Method: ${name}, Time: ${ms}` // override default formatter
);

benchmark(
    100000,
    [() =&gt; {/* Do thing one   */}, &#39;Thing 1 description&#39;],
    [() =&gt; {/* Do thing two   */}, &#39;Thing 2 description&#39;],
    [() =&gt; {/* Do thing three */}, &#39;Thing 3 description&#39;]
);

// Use a map, maps are fun
const things = new Map();
things.set(() =&gt; {/* Do thing one   */}, &#39;Thing 1 description&#39;);
things.set(() =&gt; {/* Do thing two   */}, &#39;Thing 2 description&#39;);
things.set(() =&gt; {/* Do thing three */}, &#39;Thing 3 description&#39;);

benchmark(1e5, ...things);</code></pre>
<h3 id="this-is-a-classic-optimisation-example">This is a classic optimisation example</h3>
<pre><code class="language-js">const { Benchmark } = require(&#39;oh-my-gauge&#39;)

const benchmark = new Benchmark()

const numbers = (size, from = 0) =&gt; Array.from(Array(size)).map((i, n) =&gt; n + from)

const tests = new Map()

const option1 = () =&gt; (numbers(100, 1))
    .map((i) =&gt; i * 3)
    .filter((i) =&gt; i % 2)
    .reduce((i, a) =&gt; i + a, 100)
tests.set(option1, &#39;Option 1: A neat one liner&#39;)

const option2 = () =&gt; (numbers(100, 1))
    .reduce((i, a) =&gt; {
        const three = a * 3
        return three % 2 ? three + i : three
    }, 100)
tests.set(option2, &#39;Option 2: A one loop reducer&#39;)


benchmark(1e5, ...tests)</code></pre>
<table>
<thead>
<tr>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option 1: A neat one liner took 1084ms</code><br><code>Option 2: A one loop reducer took 553ms</code></td>
</tr>
</tbody></table>
	</body>
</html>
